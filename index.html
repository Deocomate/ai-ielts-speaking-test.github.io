<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IELTS Speaking Practice with AI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }

        /* Custom styles for chat bubbles */
        .chat-bubble {
            max-width: 85%;
            padding: 12px 18px;
            border-radius: 20px;
            margin-bottom: 12px;
            word-wrap: break-word;
        }

        .chat-bubble-ai {
            background-color: #f1f5f9;
            /* slate-100 */
            color: #1e293b;
            /* slate-800 */
            align-self: flex-start;
            border-bottom-left-radius: 4px;
        }

        .chat-bubble-user {
            background-color: #2563eb;
            /* blue-600 */
            color: white;
            align-self: flex-end;
            border-bottom-right-radius: 4px;
        }

        /* Blinking dot animation */
        @keyframes blink {
            50% {
                opacity: 0;
            }
        }

        .blinking-dot {
            animation: blink 1.4s linear infinite;
        }

        /* Simple markdown parsing for evaluation */
        #evaluationResult h3 {
            font-size: 1.125rem;
            /* text-lg */
            font-weight: 600;
            /* font-semibold */
            margin-top: 1.5rem;
            /* mt-6 */
            margin-bottom: 0.5rem;
            /* mb-2 */
            border-bottom: 1px solid #e2e8f0;
            /* border-b border-slate-200 */
            padding-bottom: 0.5rem;
            /* pb-2 */
            color: #1e293b;
            /* slate-800 */
        }

        #evaluationResult p {
            margin-bottom: 1rem;
            /* mb-4 */
            line-height: 1.6;
        }

        #evaluationResult ul {
            list-style-type: disc;
            padding-left: 1.5rem;
            /* pl-6 */
            margin-bottom: 1rem;
            /* mb-4 */
        }

        #evaluationResult strong {
            font-weight: 600;
            /* font-semibold */
            color: #0f172a;
            /* slate-900 */
        }
    </style>
</head>

<body class="bg-slate-50 text-slate-800 flex items-center justify-center min-h-screen p-4">

    <div class="bg-white p-6 sm:p-8 rounded-2xl shadow-2xl w-full max-w-3xl flex flex-col" style="height: 90vh;">
        <header class="text-center border-b pb-4 mb-4">
            <h1 class="text-2xl sm:text-3xl font-bold text-slate-900">IELTS Speaking Practice with AI</h1>
            <p class="text-sm text-slate-500 mt-1">Powered by Google Gemini</p>
        </header>

        <div id="apiKeySection" class="w-full max-w-md mx-auto my-auto">
            <h2 class="text-lg font-semibold text-center mb-4">Nh·∫≠p API Key c·ªßa b·∫°n</h2>
            <p class="text-center text-sm text-slate-600 mb-4">
                Kh√≥a c·ªßa b·∫°n ƒë∆∞·ª£c l∆∞u tr·ªØ c·ª•c b·ªô trong tr√¨nh duy·ªát.
                L·∫•y kh√≥a c·ªßa b·∫°n t·ª´ <a href="https://aistudio.google.com/app/apikey" target="_blank"
                    class="text-blue-600 hover:underline">Google AI Studio</a>.
            </p>
            <div class="flex flex-col sm:flex-row gap-2">
                <input type="password" id="apiKeyInput"
                    class="flex-grow p-3 border border-slate-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:outline-none transition"
                    placeholder="Nh·∫≠p Google Gemini API Key c·ªßa b·∫°n">
                <button id="saveApiKeyBtn"
                    class="bg-blue-600 text-white px-6 py-3 rounded-lg font-semibold hover:bg-blue-700 transition shadow-sm">L∆∞u
                    & B·∫Øt ƒë·∫ßu</button>
            </div>
        </div>

        <main id="appSection" class="hidden flex-grow flex flex-col overflow-hidden">
            <div id="conversationLog"
                class="flex-grow overflow-y-auto p-4 space-y-4 flex flex-col bg-slate-50 rounded-lg mb-4">
            </div>

            <div id="statusIndicator"
                class="text-center p-3 h-16 flex items-center justify-center rounded-lg bg-slate-100 transition-all duration-300">
                <p id="statusText" class="text-slate-600 font-medium">Nh·∫•n "B·∫Øt ƒë·∫ßu Thi" ƒë·ªÉ kh·ªüi ƒë·ªông.</p>
            </div>

            <div id="controls" class="mt-4 flex items-center justify-center gap-4">
                <button id="controlButton"
                    class="bg-blue-600 text-white px-8 py-3 rounded-lg font-semibold hover:bg-blue-700 transition shadow-sm w-full max-w-xs">
                    B·∫Øt ƒë·∫ßu Thi
                </button>
                <button id="stopTestBtn"
                    class="hidden bg-red-600 text-white px-6 py-3 rounded-lg font-semibold hover:bg-red-700 transition shadow-sm">
                    D·ª´ng Thi
                </button>
            </div>
            <div class="text-center mt-4">
                <button id="changeApiBtn" class="text-sm text-slate-500 hover:text-blue-600">ƒê·ªïi Key</button>
            </div>
        </main>

        <div id="evaluationSection" class="hidden flex-grow flex flex-col overflow-hidden">
            <h2 class="text-2xl font-bold text-center mb-4 text-slate-900">ƒê√°nh gi√° B√†i thi N√≥i IELTS</h2>
            <div id="evaluationResult" class="flex-grow overflow-y-auto p-4 bg-slate-50 rounded-lg">
            </div>
            <div class="text-center mt-6">
                <button id="restartTestBtn"
                    class="bg-blue-600 text-white px-8 py-3 rounded-lg font-semibold hover:bg-blue-700 transition shadow-sm">
                    B·∫Øt ƒë·∫ßu B√†i thi M·ªõi
                </button>
            </div>
        </div>
    </div>

    <script>
        // --- DOM ELEMENTS ---
        const apiKeySection = document.getElementById('apiKeySection');
        const appSection = document.getElementById('appSection');
        const evaluationSection = document.getElementById('evaluationSection');
        const apiKeyInput = document.getElementById('apiKeyInput');
        const saveApiKeyBtn = document.getElementById('saveApiKeyBtn');
        const changeApiBtn = document.getElementById('changeApiBtn');
        const conversationLog = document.getElementById('conversationLog');
        const statusIndicator = document.getElementById('statusIndicator');
        const statusText = document.getElementById('statusText');
        const controlButton = document.getElementById('controlButton');
        const stopTestBtn = document.getElementById('stopTestBtn');
        const evaluationResult = document.getElementById('evaluationResult');
        const restartTestBtn = document.getElementById('restartTestBtn');
        const controlsDiv = document.getElementById('controls');

        // --- STATE MANAGEMENT ---
        let geminiApiKey = '';
        let conversationHistory = [];
        let isTestRunning = false;
        let isListening = false;
        let isAISpeaking = false;
        let mediaRecorder;
        let audioChunks = [];
        let preparationTimer;
        let voices = [];
        let originalControlButtonHandler;

        // --- CONSTANTS ---
        const API_URL = (model) => `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=`;
        const SYSTEM_INSTRUCTION = {
            role: "user",
            parts: [{
                text: `YOU ARE AN IELTS SPEAKING EXAMINER

**Role and Objective:**
You are a professional and experienced IELTS speaking examiner. Your task is to conduct a full IELTS speaking test (Parts 1, 2, and 3) with me, the test-taker. The goal is to accurately simulate a real exam and then provide detailed, constructive feedback.

**Procedure and Guidelines:**

**Crucial Rule: You must operate in a turn-by-turn manner. Ask only one question (or provide one instruction, like the Part 2 cue card), and then WAIT for my response. Do not provide the next question or part of the test until after I have responded.**

1.  **Starting the Test:**
    * Greet me and perform the opening procedures like a real examiner (e.g., "Good morning, my name is Gemini. Can you tell me your full name, please? And what can I call you?").
    * Briefly introduce the 3-part structure of the test.

2.  **Conducting Part 1 (4-5 minutes):**
    * Ask me a series of questions on familiar topics such as hometown, family, work/studies, and hobbies.

3.  **Conducting Part 2 (3-4 minutes):**
    * Introduce Part 2 by saying "Now, I'm going to give you a topic...".
    * Give me a clear cue card.
    * Clearly state that I have 1 minute to prepare and can make notes.
    * Ask me to start speaking and listen for 1-2 minutes.
    * After I finish, ask 1-2 brief follow-up questions related to the topic.

4.  **Conducting Part 3 (4-5 minutes):**
    * Transition to Part 3 by asking more abstract, discussion-based questions related to the Part 2 topic.

5.  **Ending and Evaluating:**
    * After completing Part 3, clearly announce the end of the test ("That is the end of the speaking test.").
    * **Important:** Immediately after this sentence, switch to the role of an expert evaluator. Provide a detailed analysis of my performance using the following exact format. Do not add any conversational text before or after this structure.
    
    ### Overall Band Score: [Provide a single number, e.g., 7.5]
    
    ### Fluency and Coherence
    [Provide your detailed analysis for this criterion here. Use bullet points for specific examples.]
    
    ### Lexical Resource
    [Provide your detailed analysis for this criterion here. Use bullet points for specific examples.]
    
    ### Grammatical Range and Accuracy
    [Provide your detailed analysis for this criterion here. Use bullet points for specific examples.]
    
    ### Pronunciation
    [Provide your detailed analysis for this criterion here. Use bullet points for specific examples.]
    
    ### Actionable Advice for Improvement
    [Provide your detailed analysis for this criterion here. Use bullet points for specific suggestions.]

Now, let's begin. I am ready for the test.`
            }]
        };

        // --- TEXT-TO-SPEECH FUNCTIONS ---
        // Initialize voice list as soon as possible
        function initVoices() {
            return new Promise((resolve) => {
                voices = window.speechSynthesis.getVoices();
                if (voices.length > 0) {
                    resolve(voices);
                } else {
                    window.speechSynthesis.onvoiceschanged = () => {
                        voices = window.speechSynthesis.getVoices();
                        resolve(voices);
                    };
                }
            });
        }

        // Function to speak text using Web Speech API with better mobile support
        function speakText(text) {
            // Stop any current speech
            window.speechSynthesis.cancel();

            // Create a new speech utterance
            const utterance = new SpeechSynthesisUtterance(text);

            // Set properties
            utterance.rate = 0.9; // Slightly slower for clarity
            utterance.pitch = 1;
            utterance.volume = 1;

            // Select a voice (English voice)
            // Try to find a good English voice
            const englishVoice = voices.find(voice =>
                voice.lang.includes('en') &&
                (voice.name.includes('Daniel') || voice.name.includes('Google') || voice.name.includes('Male'))
            ) || voices[0];

            if (englishVoice) {
                utterance.voice = englishVoice;
            }

            // Set up events
            utterance.onstart = () => {
                isAISpeaking = true;
                updateStatus('AI ƒëang n√≥i...', true);
            };

            utterance.onend = () => {
                isAISpeaking = false;
                if (isTestRunning) {
                    if (text.toLowerCase().includes("i'm going to give you a topic")) {
                        startPart2Preparation();
                    } else {
                        startListening();
                    }
                }
            };

            utterance.onerror = (e) => {
                console.error("Speech synthesis error:", e);
                isAISpeaking = false;
                // Continue the test even if speech fails
                if (isTestRunning) {
                    if (text.toLowerCase().includes("i'm going to give you a topic")) {
                        startPart2Preparation();
                    } else {
                        startListening();
                    }
                }
            };

            // Try to speak the text
            try {
                window.speechSynthesis.speak(utterance);

                // Special handling for mobile: check if speech actually started
                // This is particularly important for iOS devices
                setTimeout(() => {
                    if (window.speechSynthesis.speaking === false && isAISpeaking === true) {
                        // Speech didn't actually start despite no error
                        console.log("Speech didn't start properly - common on mobile");
                        isAISpeaking = false;

                        // Update UI to show the user they need to continue manually
                        updateStatus('Nh·∫•n v√†o "Nghe l·∫°i" ho·∫∑c b·∫•m "Ti·∫øp t·ª•c" ƒë·ªÉ ti·∫øp t·ª•c b√†i thi', false);

                        // Show a continue button
                        showContinueButton(text);
                    }
                }, 500);
            } catch (e) {
                console.error("Error attempting speech synthesis:", e);
                isAISpeaking = false;

                // Show continue button if speech fails
                showContinueButton(text);
            }
        }

        // Function to show a continue button when speech fails
        function showContinueButton(text) {
            // Create continue button if it doesn't exist
            if (!document.getElementById('continueButton')) {
                const continueButton = document.createElement('button');
                continueButton.id = 'continueButton';
                continueButton.className = 'bg-green-600 text-white px-6 py-3 rounded-lg font-semibold hover:bg-green-700 transition shadow-sm';
                continueButton.innerText = 'Ti·∫øp t·ª•c b√†i thi';
                continueButton.onclick = () => {
                    if (isTestRunning) {
                        if (text.toLowerCase().includes("i'm going to give you a topic")) {
                            startPart2Preparation();
                        } else {
                            startListening();
                        }
                        continueButton.remove();
                    }
                };

                // Add to the controls div
                controlsDiv.appendChild(continueButton);
            }
        }

        // --- INITIALIZATION ---
        window.addEventListener('DOMContentLoaded', async () => {
            // Initialize voices
            await initVoices();

            // Store the original control button handler
            originalControlButtonHandler = handleControlButtonClick;

            geminiApiKey = localStorage.getItem('geminiApiKey');
            if (geminiApiKey) {
                apiKeyInput.value = geminiApiKey;
                showApp();
            } else {
                showApiKeySection();
            }

            saveApiKeyBtn.addEventListener('click', saveApiKey);
            changeApiBtn.addEventListener('click', () => {
                if (isTestRunning) {
                    if (!confirm("B·∫°n c√≥ ch·∫Øc mu·ªën k·∫øt th√∫c b√†i thi hi·ªán t·∫°i v√† ƒë·ªïi API key kh√¥ng?")) return;
                }
                resetApp();
                showApiKeySection();
            });
            controlButton.addEventListener('click', handleControlButtonClick);
            stopTestBtn.addEventListener('click', () => {
                if (confirm("B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën d·ª´ng b√†i thi ngay l·∫≠p t·ª©c kh√¥ng?")) {
                    resetApp();
                }
            });
            restartTestBtn.addEventListener('click', () => {
                resetApp();
                showApp();
            });
        });

        // --- UI MANAGEMENT ---
        function showApiKeySection() {
            apiKeySection.classList.remove('hidden');
            appSection.classList.add('hidden');
            evaluationSection.classList.add('hidden');
        }

        function showApp() {
            apiKeySection.classList.add('hidden');
            appSection.classList.remove('hidden');
            appSection.classList.add('flex');
            evaluationSection.classList.add('hidden');
        }

        function showEvaluation() {
            appSection.classList.add('hidden');
            appSection.classList.remove('flex');
            evaluationSection.classList.remove('hidden');
            evaluationSection.classList.add('flex');
        }

        function updateStatus(text, isBlinking = false) {
            statusText.innerHTML = text;
            if (isBlinking) {
                statusIndicator.classList.add('bg-yellow-100');
                statusText.innerHTML += ' <span class="blinking-dot">‚óè</span>';
            } else {
                statusIndicator.classList.remove('bg-yellow-100');
            }
        }

        function addMessageToLog(text, sender) {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('chat-bubble', sender === 'ai' ? 'chat-bubble-ai' : 'chat-bubble-user');

            if (sender === 'ai') {
                const textDiv = document.createElement('div');
                textDiv.innerText = text;

                const replayButton = document.createElement('button');
                replayButton.innerHTML = 'üîä Nghe l·∫°i';
                replayButton.className = 'text-xs bg-slate-200 hover:bg-slate-300 p-1 mt-2 rounded';
                replayButton.dataset.text = text;
                replayButton.onclick = function () {
                    speakText(text);

                    // When replay is clicked, also prepare for the next part of the test
                    setTimeout(() => {
                        if (!isAISpeaking && !isListening && isTestRunning) {
                            // Reset control button to allow proceeding with the test
                            updateControlButtonForManualProgress(text);
                        }
                    }, 300);
                };

                messageDiv.appendChild(textDiv);
                messageDiv.appendChild(replayButton);
            } else {
                messageDiv.innerText = text;
            }

            conversationLog.appendChild(messageDiv);
            conversationLog.scrollTop = conversationLog.scrollHeight;
        }

        // Function to update control button for manual progression
        function updateControlButtonForManualProgress(text) {
            if (isTestRunning) {
                // Enable control button and change text to allow manual continuation
                controlButton.disabled = false;
                controlButton.innerText = 'B·∫Øt ƒë·∫ßu tr·∫£ l·ªùi';

                // Store the original handler
                const originalHandler = controlButton.onclick;

                // Set new handler
                controlButton.onclick = () => {
                    // Reset onclick to original behavior
                    controlButton.onclick = originalControlButtonHandler;

                    if (text.toLowerCase().includes("i'm going to give you a topic")) {
                        startPart2Preparation();
                    } else {
                        startListening();
                    }
                };
            }
        }

        // --- CORE LOGIC ---
        function saveApiKey() {
            const key = apiKeyInput.value.trim();
            if (key) {
                geminiApiKey = key;
                localStorage.setItem('geminiApiKey', key);
                showApp();
            } else {
                alert('Vui l√≤ng nh·∫≠p m·ªôt API key h·ª£p l·ªá.');
            }
        }

        async function handleControlButtonClick() {
            if (!isTestRunning) {
                await startTest();
            } else if (isListening) {
                stopListening();
            }
        }

        async function startTest() {
            isTestRunning = true;
            controlButton.disabled = true;
            controlButton.innerText = 'B√†i thi ƒëang di·ªÖn ra...';
            stopTestBtn.classList.remove('hidden');
            updateStatus('ƒêang kh·ªüi t·∫°o b√†i thi...', true);

            // Remove any previous continue buttons
            const continueButton = document.getElementById('continueButton');
            if (continueButton) continueButton.remove();

            conversationHistory = [SYSTEM_INSTRUCTION];

            try {
                const firstUserMessage = { role: "user", parts: [{ text: "Please begin the test." }] };
                conversationHistory.push(firstUserMessage);

                const aiResponse = await callGeminiApi(conversationHistory, 'gemini-1.5-flash-latest');
                await handleAIResponse(aiResponse);
            } catch (error) {
                console.error("L·ªói khi b·∫Øt ƒë·∫ßu b√†i thi:", error);
                alert("Kh√¥ng th·ªÉ b·∫Øt ƒë·∫ßu b√†i thi. Ki·ªÉm tra API key v√† console ƒë·ªÉ bi·∫øt l·ªói.");
                resetApp();
            }
        }

        async function handleAIResponse(text) {
            addMessageToLog(text, 'ai');
            conversationHistory.push({ role: "model", parts: [{ text }] });

            if (text.toLowerCase().includes("that is the end of the speaking test")) {
                await endTestAndEvaluate();
                return;
            }

            // Try to speak the AI response
            speakText(text);

            // Ensure the user can proceed even if speech fails
            setTimeout(() => {
                // If after 1 second we're not speaking and not listening, update control button
                if (!isAISpeaking && !isListening && isTestRunning) {
                    updateControlButtonForManualProgress(text);
                }
            }, 1000);
        }

        function startPart2Preparation() {
            // Cancel any ongoing speech
            window.speechSynthesis.cancel();

            // Remove any continue button if it exists
            const continueButton = document.getElementById('continueButton');
            if (continueButton) continueButton.remove();

            let timeLeft = 60;
            controlButton.disabled = true;
            controlButton.innerText = 'ƒêang chu·∫©n b·ªã...';
            updateStatus(`Th·ªùi gian chu·∫©n b·ªã: ${timeLeft} gi√¢y`);

            preparationTimer = setInterval(() => {
                timeLeft--;
                updateStatus(`Th·ªùi gian chu·∫©n b·ªã: ${timeLeft} gi√¢y`);
                if (timeLeft <= 0) {
                    clearInterval(preparationTimer);
                    addMessageToLog("Your preparation time is over. Please start speaking now.", 'ai');
                    speakText("Your preparation time is over. Please start speaking now.");
                }
            }, 1000);
        }

        function startListening() {
            if (isAISpeaking) return;

            // Remove any continue button if it exists
            const continueButton = document.getElementById('continueButton');
            if (continueButton) continueButton.remove();

            isListening = true;
            controlButton.disabled = false;
            controlButton.innerText = 'D·ª´ng Ghi √¢m';
            // Reset the control button's onclick to the original handler
            controlButton.onclick = originalControlButtonHandler;

            updateStatus('ƒêang nghe... M·ªùi b·∫°n n√≥i.', true);

            navigator.mediaDevices.getUserMedia({ audio: true })
                .then(stream => {
                    mediaRecorder = new MediaRecorder(stream);
                    audioChunks = [];
                    mediaRecorder.ondataavailable = event => {
                        audioChunks.push(event.data);
                    };
                    mediaRecorder.onstop = processAudio;
                    mediaRecorder.start();
                }).catch(err => {
                    console.error("L·ªói truy c·∫≠p micro:", err);
                    alert("Kh√¥ng th·ªÉ truy c·∫≠p micro. Vui l√≤ng c·∫•p quy·ªÅn v√† th·ª≠ l·∫°i.");
                    resetApp();
                });
        }

        function stopListening() {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
                isListening = false;
                controlButton.disabled = true;
                controlButton.innerText = 'ƒêang x·ª≠ l√Ω...';
                updateStatus('ƒêang x·ª≠ l√Ω c√¢u tr·∫£ l·ªùi c·ªßa b·∫°n...', true);
            }
        }

        async function processAudio() {
            const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
            const reader = new FileReader();
            reader.readAsDataURL(audioBlob);
            reader.onloadend = async () => {
                const base64Audio = reader.result.split(',')[1];
                const userMessage = {
                    role: "user",
                    parts: [{ inline_data: { mime_type: "audio/webm", data: base64Audio } },
                    { text: "Here is my audio response. Please continue the test." }]
                };
                conversationHistory.push(userMessage);
                addMessageToLog("[C√¢u tr·∫£ l·ªùi b·∫±ng √¢m thanh c·ªßa b·∫°n ƒë√£ ƒë∆∞·ª£c g·ª≠i]", 'user');

                try {
                    updateStatus('AI ƒëang suy nghƒ©...', true);
                    const aiResponse = await callGeminiApi(conversationHistory, 'gemini-1.5-flash-latest');
                    await handleAIResponse(aiResponse);
                } catch (error) {
                    console.error("L·ªói sau khi g·ª≠i √¢m thanh:", error);
                    alert("ƒê√£ x·∫£y ra l·ªói khi x·ª≠ l√Ω c√¢u tr·∫£ l·ªùi c·ªßa b·∫°n. Vui l√≤ng ki·ªÉm tra console.");
                    resetApp();
                }
            };
        }

        async function endTestAndEvaluate() {
            // Cancel any ongoing speech
            window.speechSynthesis.cancel();

            // Remove any continue button if it exists
            const continueButton = document.getElementById('continueButton');
            if (continueButton) continueButton.remove();

            updateStatus('B√†i thi k·∫øt th√∫c. ƒêang t·∫°o ph·∫£n h·ªìi cho b·∫°n...', true);
            isTestRunning = false;
            controlButton.style.display = 'none';
            stopTestBtn.classList.add('hidden');

            try {
                const feedback = await callGeminiApi(conversationHistory, 'gemini-1.5-flash-latest');
                displayEvaluation(feedback);
            } catch (error) {
                console.error("L·ªói khi l·∫•y ƒë√°nh gi√°:", error);
                displayEvaluation("Xin l·ªói, ƒë√£ c√≥ l·ªói x·∫£y ra khi t·∫°o ph·∫£n h·ªìi c·ªßa b·∫°n. Vui l√≤ng th·ª≠ l·∫°i.");
            }
        }

        function displayEvaluation(feedbackText) {
            let html = '';
            const scoreMatch = feedbackText.match(/### Overall Band Score: ([\d.]+)/);

            if (scoreMatch && scoreMatch[1]) {
                const score = scoreMatch[1];
                html += `<div class="text-center mb-6 p-4 bg-white rounded-lg shadow">
                            <p class="text-base font-medium text-slate-600">D·ª± ki·∫øn Band ƒëi·ªÉm Speaking</p>
                            <p class="text-6xl font-bold text-blue-600 my-2">${score}</p>
                         </div>`;
            }

            const restOfFeedback = feedbackText.replace(/### Overall Band Score: ([\d.]+)/, '');
            const processedFeedback = restOfFeedback
                .replace(/### (.*?)(?:\r\n|\r|\n)/g, '<h3>$1</h3>')
                .replace(/\* (.*?)(?:\r\n|\r|\n)/g, '<li>$1</li>')
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            html += processedFeedback.replace(/(<li>.*?<\/li>)/gs, '<ul>$1</ul>').replace(/<\/ul>\s*<ul>/g, '');

            evaluationResult.innerHTML = html;
            showEvaluation();
        }

        function resetApp() {
            // Cancel any ongoing speech
            window.speechSynthesis.cancel();

            // Remove any continue button if it exists
            const continueButton = document.getElementById('continueButton');
            if (continueButton) continueButton.remove();

            isTestRunning = false;
            isListening = false;
            isAISpeaking = false;
            clearInterval(preparationTimer);
            if (mediaRecorder && mediaRecorder.state === 'recording') mediaRecorder.stop();
            conversationHistory = [];
            conversationLog.innerHTML = '';
            controlButton.innerText = 'B·∫Øt ƒë·∫ßu Thi';
            controlButton.disabled = false;
            controlButton.style.display = 'block';
            // Reset the control button's onclick to the original handler
            controlButton.onclick = originalControlButtonHandler;
            stopTestBtn.classList.add('hidden');
            updateStatus('Nh·∫•n "B·∫Øt ƒë·∫ßu Thi" ƒë·ªÉ kh·ªüi ƒë·ªông.');
        }

        // --- API & UTILITY FUNCTIONS ---
        async function callGeminiApi(history, model) {
            const response = await fetch(API_URL(model) + geminiApiKey, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ contents: history })
            });
            if (!response.ok) {
                const errorBody = await response.json();
                console.error("L·ªói API:", errorBody);
                throw new Error(`Y√™u c·∫ßu API th·∫•t b·∫°i v·ªõi tr·∫°ng th√°i ${response.status}: ${errorBody.error.message}`);
            }
            const data = await response.json();
            if (data.candidates && data.candidates[0].content.parts[0].text) {
                return data.candidates[0].content.parts[0].text;
            }
            throw new Error("Ph·∫£n h·ªìi API kh√¥ng h·ª£p l·ªá.");
        }
    </script>
</body>

</html>